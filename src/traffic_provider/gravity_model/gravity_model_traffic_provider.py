"""
Mathhew Roughan et. al in 'The many facets of Internet topology and traffic':
Gravity Model for TM synthesizing:
X_ij = R_i * A_j / f_ij
R_i as the volume of incoming traffic
A_j as the outgoing traffic

The friction matrix (fij ) encodes the locality information specific to different source-destination pairs, however,
as locality is not as large a factor in Internet traffic as in the
transport of physical goods, we shall assume a lp constant for the friction factors.
Real traffic matrices may have non-constant fij , (perhaps as a db_result of different time-zones),

- interesting: traffic follows 80-20 law (20% of flows cause 80% of traffic
- interesting: gravity model on geant works but only with aggregation (1. simple gravity model with N + 7 and then aggregate 8 of these nodes)

Note: while Matthew Roughan in 'Simplifying the synthesis of Internet traffic matrices' describes that the matrix is generated by using
"""

import numpy as np
import scipy.stats as st

from traffic_provider.generic_tm_provider import GenericTM


class GravityModel(GenericTM):
    def __init__(self, node_info: dict, tm_sample_nr: int, gm_scale: float, gm_type: str = "1_random_var",
                 gm_distribution: str = "exp", gm_loc: float = 100, gm_seed: float = 0, tm_fixed_total: float = None):
        """
        creates a traffic matrix of size n using the gravity model with independent exponential or gauss distribution of ingress and egress traffic
        :param node_info: node info generated by topology provider
        :param tm_sample_nr: sample number of gravity model
        :param gm_scale: mean for random vector generation
        :param gm_type: generate matrix using 1 or 2 random vectors gm_type = ['1_random_var', '2_random_var']
        :param gm_distribution: define which distribution function is used to generate random vectors; gm_distribution = ['exp', 'gauss']
        :param gm_loc: loc parameter for generating random vectors
        :param gm_seed: seed for generating random numbers
        :param tm_fixed_total: if this is non zero the sum of all tm entries gets transformed to this value
        """
        np.random.seed(gm_seed)
        if not gm_distribution == "exp" and not gm_distribution == "gauss":
            raise Exception("the defined distribution is not supported use [exp, gauss]")
        if not gm_type == "2_random_var" and not gm_type == "1_random_var":
            raise Exception("the defined gravity model type is not supported  use [1_random_var, 2_random_var]")

        self.seed = gm_seed
        self.sample_nr = tm_sample_nr
        self.type = gm_type
        self.scale = gm_scale
        self.n = len(node_info)
        self.distribution = gm_distribution
        self.loc = gm_loc
        self.tm_fixed_total = tm_fixed_total
        return

    def __get_random_vector(self):
        if self.distribution == "exp":
            t = np.array([st.expon.rvs(size=self.n, scale=self.scale)])
        elif self.distribution == "gauss":
            t = np.array([st.norm.rvs(size=self.n, scale=self.scale, loc=self.loc)]).clip(min=0)
        else:
            raise Exception("Gravity Model does not support the defined distribution. choose: ['exp', 'gauss']")
        return t

    def __get_transformed_tm(self, tm):
        total_demand, n_entries, mean = super().get_basic_stats(tm)
        dm = self.tm_fixed_total / total_demand
        tm.update((pair, demand * dm) for pair, demand in tm.items())
        return tm

    def __get_traffic(self):
        t_in = self.__get_random_vector()
        t_out = t_in

        if self.type == "2_random_var":
            t_out = self.__get_random_vector()

        t = (np.sum(t_in) + np.sum(t_out)) / 2  # assumption that sum(t_in) == sum(t_out) == t

        # probability matrix
        p_in = t_in / np.sum(t_in)
        p_out = t_out / np.sum(t_out)
        p_matrix = np.matmul(p_in.T, p_out)

        # traffic matrix
        t_matrix = p_matrix * t
        traffic_matrix = {(i, j): t_matrix[i][j] for i in range(self.n) for j in range(self.n) if
                          i != j and t_matrix[i][j] > 0}
        return traffic_matrix

    def get_traffic_matrix(self) -> dict:
        """ see generic_tm_provider.py """
        tm = self.__get_traffic()
        if self.tm_fixed_total is None or self.tm_fixed_total <= 0:
            return tm
        return self.__get_transformed_tm(tm)

    def get_name(self) -> str:
        """ see generic_tm_provider.py """
        return f"GM_scl_{self.scale:.1f}_loc_{self.loc:.1f}_t_{self.type}" \
               f"_dist_{self.distribution}_seed_{self.seed}_nr_{self.sample_nr}"
